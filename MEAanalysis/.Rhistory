# output_table <- burst_duration() #calculates the mean, sd, and se burst duration within a given time interval by electrode (for a specific recording)
# output_table <- spikes_per_burst() #calculates mean, sd, and se number of spikes per burst within a given time interval by electrode (for a specific recording)
# output_table <- mean_burst_ISI() #calculates average, sd, and se mean ISI within a burst (sec) for a given time interval by electrode (for a specific recording)
# EXAMPLE CODE: calculates each parameter for each individual electrode within the given time interval for a recording
output_table <- electrode_burst_duration(data = output_table, 0, 30, recording_identifier = "test_data_1")
output_table <- electrode_burst_duration(data = output_table, 30, 60, recording_identifier = "test_data_1")
output_table <- electrode_burst_duration(data = output_table, 60, 90, recording_identifier = "test_data_1")
output_table <- electrode_burst_duration(data = output_table, 60, 90, recording_identifier = "test_data_2")
output_table <- electrode_spikes_per_burst(data = output_table, 0, 30, recording_identifier = "test_data_1")
output_table <- electrode_spikes_per_burst(data = output_table, 30, 60, recording_identifier = "test_data_1")
output_table <- electrode_spikes_per_burst(data = output_table, 60, 90, recording_identifier = "test_data_1")
output_table <- electrode_spikes_per_burst(data = output_table, 60, 90, recording_identifier = "test_data_2")
output_table <- electrode_mean_burst_ISI(data = output_table, 0, 30, recording_identifier = "test_data_1")
output_table <- electrode_mean_burst_ISI(data = output_table, 30, 60, recording_identifier = "test_data_1")
output_table <- electrode_mean_burst_ISI(data = output_table, 60, 90, recording_identifier = "test_data_1")
output_table <- electrode_mean_burst_ISI(data = output_table, 60, 90, recording_identifier = "test_data_2")
output_table <- electrode_number_of_bursts(data = output_table, 0, 30, recording_identifier = "test_data_1")
output_table <- electrode_number_of_bursts(data = output_table, 30, 60, recording_identifier = "test_data_1")
output_table <- electrode_number_of_bursts(data = output_table, 60, 90, recording_identifier = "test_data_1")
output_table <- electrode_number_of_bursts(data = output_table, 60, 90, recording_identifier = "test_data_2")
# Following code creates a bar chart of the calculated MEA parameter grouped by single electrode
# User to update function arguments accordingly i.e., single_electrode_barchart(data, electrode_parameter, electrode_filter, statistic)
# For electrode_parameter argument include "number_of_bursts"/ "burst_duration"/ "spikes_per_burst"/ "mean_burst_ISI"
# Note statistics will not be calculated for the number of bursts within a given time interval
single_electrode_barchart(data = output_table, electrode_parameter = "burst_duration", electrode_filter = "A1_", statistic = se)
single_electrode_barchart(data = output_table, electrode_parameter = "spikes_per_burst", electrode_filter = "A1_", statistic = se)
single_electrode_barchart(data = output_table, electrode_parameter = "mean_burst_ISI", electrode_filter = "A1_", statistic = se)
single_electrode_barchart(data = output_table, electrode_parameter = "number_of_bursts", electrode_filter = "A1_")
test_data_1 <- create_electrode_dataset(data_path = "./data/baseline_electrode_burst_list.csv",
recording_identifier = "test_data_1")
test_data_2 <- create_electrode_dataset(data_path = "./data/comparison_agonist_challenge_electrode_burst_list.csv",
recording_identifier = "test_data_2")
output_table <- rbind(test_data_1, test_data_2)
test_data_1 <- create_electrode_dataset(data_path = "./data/baseline_electrode_burst_list.csv",
recording_identifier = "test_data_1")
test_data_2 <- create_electrode_dataset(data_path = "./data/comparison_agonist_challenge_electrode_burst_list.csv",
recording_identifier = "test_data_2")
baseline_data <- create_synchrony_dataset(data_path = "./data/baseline_neuralMetrics.csv",
heatmap_condition = "Baseline")
agonist_challenge_data <- create_synchrony_dataset(data_path = "./data/comparison_agonist_challenge_neuralMetrics.csv",
heatmap_condition = "Agonist Challenge")
devtools::document()
library(MEAanalysis)
library(MEAanalysis)
devtools::document()
library(MEAanalysis)
pkgload::dev_help('create_electrode_dataset')
pkgload::load_all()
pkgload::dev_help('create_electrode_dataset')
library(MEAanalysis)
devtools::document()
usethis::use_test("MEA_heatmap")
usethis::use_test("create_synchrony_dataset")
usethis::use_test("create_electrode_dataset")
usethis::use_test("electrode_burst_duration")
usethis::use_test("electrode_mean_burst_ISI)
usethis::use_test("electrode_mean_burst_ISI")
usethis::use_test("electrode_mean_burst_ISI")
usethis::use_test("electrode_number_of_bursts")
usethis::use_test("electrode_spikes_per_burst")
usethis::use_test("single_electrode_barchart")
usethis::use_test("well_barchart")
usethis::use_test("well_burst_duration")
usethis::use_test("well_mean_burst_ISI")
usethis::use_test("well_number_of_bursts")
usethis::use_test("well_spikes_per_burst")
devtools::test()
View(baseline_data)
View(agonist_challenge_data)
test_data_1 <- create_electrode_dataset(data_path = "./inst/data/baseline_electrode_burst_list.csv",
recording_identifier = "test_data_1")
View(test_data_1)
data_path = "MEAanalysis/data/input_electrode_burst.csv"
recording_identifier = "burst_recording_1"
# read in electrode_burst_list file produced by axis navigator software (update data_path accordingly)
input_data <- read_csv(file = data_path, col_select = 3:6, show_col_types = FALSE)
data_path = "data/input_electrode_burst.csv"
# read in electrode_burst_list file produced by axis navigator software (update data_path accordingly)
input_data <- read_csv(file = data_path, col_select = 3:6, show_col_types = FALSE)
View(input_data)
View(test_data_2)
View(baseline_data)
View(input_data)
as.numeric(input_data, 1)
test_that("create_electrode_dataset output is a datatable", {
expect_equal(create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1"),
is.data.table == TRUE)
})
test_that("create_electrode_dataset output is a datatable", {
expect_equal(test_dataset <- create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1"),
is.data.table(test_dataset) == TRUE)
})
test_that("create_electrode_dataset output is a datatable", {
expect_equal(create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1"),
is.data.table() == TRUE)
})
test_that("create_electrode_dataset output is a datatable", {
expect_equal(is.data.table(create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1")), TRUE)
})
lapply(test_data_1, class)
sapply(test_data_1, class)
test <- sapply(test_data_1, class)
test_that("reate_electrode_dataset column classes are correct", {
expect_equal(sapply(is.data.table(create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1")), class),
c("character", "numeric", "numeric", "numeric", "character", "character")
)
})
test_that("reate_electrode_dataset column classes are correct", {
expect_equal(lapply(is.data.table(create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1")), class),
c("character", "numeric", "numeric", "numeric", "character", "character")
)
})
test_that("reate_electrode_dataset column classes are correct", {
expect_equal(unlist(lapply(is.data.table(create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1")), class)),
c("character", "numeric", "numeric", "numeric", "character", "character")
)
})
?read_delim()
data <- data.frame(
A = c(1, 2, 3),
B = c("foo", "bar", "baz"),
C = c(TRUE, FALSE, TRUE)
)
get_column_classes <- function(data) {
sapply(data, function(x) class(x))
}
column_classes <- get_column_classes(data)
test <- lapply(is.data.table(create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1")), class)
test <- sapply(test_data_1, class)
test_that("reate_electrode_dataset column classes are correct", {
expect_equal(test <- sapply(is.data.table(create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1")), class),
c("character", "numeric", "numeric", "numeric", "character", "character")
)
})
test_that("reate_electrode_dataset column classes are correct", {
expect_equal(sapply(is.data.table(create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1")), class),
c("character", "numeric", "numeric", "numeric", "character", "character")
)
})
test_that("create_electrode_dataset column classes are correct", {
expect_equal(sapply(create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1"), class),
c("character", "numeric", "numeric", "numeric", "character", "character")
)
})
sapply((create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1")), class)
test <- sapply(test_data_1, class)
sapply(test_data_1, class)
test_that("create_electrode_dataset column classes are correct", {
expect_equal(lapply((create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1")), class),
c("character", "numeric", "numeric", "numeric", "character", "character")
)
})
test_that("create_electrode_dataset column classes are correct", {
expect_equal(test <- lapply((create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1")), class),
c("character", "numeric", "numeric", "numeric", "character", "character")
)
})
class(create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1"))
class(create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1")[, 1:6])
class(create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1")[, 1])
class((create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1"))[, 1])
sapply(test_data_1, class)
create_electrode_dataset_test <- create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1")
test_that("create_electrode_dataset output is a datatable", {
expect_equal(is.data.table(create_electrode_dataset_test), TRUE)
})
sapply(create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1"), class)
lapply(create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1"), class)
test <- lapply(create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1"), class)
View(test)
test <- sapply(create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1"), class)
test_that("create_electrode_dataset column classes are correct", {
expect_equal(test <- sapply(create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1"), class),
test = c("character", "numeric", "numeric", "numeric", "character", "character"))
})
test_that("create_electrode_dataset column classes are correct", {
expect_equal(sapply(create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1"), class),
c("character", "numeric", "numeric", "numeric", "character", "character"))
})
test_that("create_electrode_dataset column classes are correct", {
expect_equal(sapply(create_electrode_dataset_test, class),
c("character", "numeric", "numeric", "numeric", "character", "character"))
})
test_that("create_electrode_dataset output is a datatable", {
expect_equal(is.data.table(create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1")), TRUE)
})
test_that("create_electrode_dataset column classes are correct", {
expect_equal(sapply(create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1"), class),
c("character", "numeric", "numeric", "numeric", "character", "character"))
})
test_that("create_electrode_dataset column classes are correct", {
expect_equal(sapply(create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1"), class),
test <- c("character", "numeric", "numeric", "numeric", "character", "character"))
})
test_that("create_electrode_dataset column classes and names are correct", {
# Load the dataset
dataset <- create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1")
# Define expected column names
expected_names <- c("Electrode", "Time_s", "Size_spikes", "Duration_s", "Recording_identifier")
# Assert that the column names match the expected names
expect_equal(colnames(dataset), expected_names,
info = "Column names should match the expected names")
# Define expected column classes
expected_classes <- c("character", "numeric", "numeric", "numeric", "character")
# Assert that the column classes match the expected classes
expect_equal(sapply(dataset, class), expected_classes,
info = "Column classes should match the expected classes")
})
test_that("create_electrode_dataset output is a datatable", {
# Load the dataset
dataset <- create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1")
expect_equal(is.data.table(dataset), TRUE)
})
test_that("create_electrode_dataset column classes and names are correct", {
# Load the dataset
dataset <- create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1")
# Define expected column names
expected_names <- c("Electrode", "Time_s", "Size_spikes", "Duration_s", "Recording_identifier", "well")
# Assert that the column names match the expected names
expect_equal(colnames(dataset), expected_names,
info = "Column names should match the expected names")
# Define expected column classes
expected_classes <- c("character", "numeric", "numeric", "numeric", "character", "character")
# Assert that the column classes match the expected classes
expect_equal(sapply(dataset, class), expected_classes,
info = "Column classes should match the expected classes")
})
test_that("create_electrode_dataset column classes and names are correct", {
# Load the dataset
dataset <- create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1")
# Define expected column names
expected_names <- c("Electrode", "Time_s", "Size_spikes", "Duration_s", "Recording_identifier", "well")
# Assert that the column names match the expected names
expect_equal(colnames(dataset), expected_names,
info = "Column names should match the expected names")
# Define expected column classes
expected_classes <- c("character", "numeric", "numeric", "numeric", "character", "character")
# Assert that the column classes match the expected classes
expect_equal(sapply(dataset, class), names(expected_classes),
info = "Column classes should match the expected classes")
})
# Define expected column classes
expected_classes <- c("character", "numeric", "numeric", "numeric", "character", "character")
test_that("create_electrode_dataset column classes and names are correct", {
# Load the dataset
dataset <- create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1")
# Define expected column names
expected_names <- c("Electrode", "Time_s", "Size_spikes", "Duration_s", "Recording_identifier", "well")
# Assert that the column names match the expected names
expect_equal(colnames(dataset), expected_names,
info = "Column names should match the expected names")
# Define expected column classes
expected_classes <- c("character", "numeric", "numeric", "numeric", "character", "character")
# Assert that the column classes match the expected classes
expect_equal(sapply(dataset, class), expected_classes,
info = "Column classes should match the expected classes")
})
test_that("create_electrode_dataset column classes and names are correct", {
# Load the dataset
dataset <- create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1")
# Define expected column names
expected_names <- c("Electrode", "Time_s", "Size_spikes", "Duration_s", "Recording_identifier", "well")
# Assert that the column names match the expected names
expect_equal(colnames(dataset), expected_names,
info = "Column names should match the expected names")
# Obtain actual column classes
actual_classes <- sapply(dataset, class)
# Define expected column classes
expected_classes <- c("character", "numeric", "numeric", "numeric", "character", "character")
# Assert that the column classes match the expected classes
expect_equal(actual_classes, expected_classes,
info = "Column classes should match the expected classes")
})
test_that("create_electrode_dataset column names are correct", {
# Load the dataset
dataset <- create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1")
# Define expected column names
expected_names <- c("Electrode", "Time_s", "Size_spikes", "Duration_s", "Recording_identifier", "well")
# Assert that the column names match the expected names
expect_equal(colnames(dataset), expected_names,
info = "Column names should match the expected names")
})
test_that("create_electrode_dataset column classes are correct", {
# Load the dataset
dataset <- create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1")
# Determine actual column classes
actual_classes <- sapply(dataset, class)
# Define expected column classes
expected_classes <- c("character", "numeric", "numeric", "numeric", "character", "character")
# Assert that the column classes match the expected classes
expect_equal(actual_classes, expected_classes,
info = "Column classes should match the expected classes")
})
test_that("create_electrode_dataset column classes are correct", {
# Load the dataset
dataset <- create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1")
# Determine actual column classes
actual_classes <- sapply(dataset, class)
# Assert that the column classes match the expected classes
expect_equal(actual_classes, c("character", "numeric", "numeric", "numeric", "character", "character"),
info = "Column classes should match the expected classes")
})
test_that("create_electrode_dataset column classes are correct", {
# Load the dataset
dataset <- create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1")
# Assert that the column classes match the expected classes
expect_equal(sapply(dataset, class), c("character", "numeric", "numeric", "numeric", "character", "character"),
info = "Column classes should match the expected classes")
})
# Determine actual column classes
actual_classes <- sapply(dataset, class)
# Load the dataset
dataset <- create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1")
# Determine actual column classes
actual_classes <- sapply(dataset, class)
# Define expected column classes
expected_classes <- c("character", "numeric", "numeric", "numeric", "character", "character")
print(actual_classes)
print(expected_classes)
test_that("create_electrode_dataset column classes are correct", {
# Load the dataset
dataset <- create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1")
# Define expected column classes
expected_columns <- data.table(
Electrode = character(),
Time_s = numeric(),
Size_spikes = numeric(),
Duration_s = numeric(),
Recording_identifier= character(),
well = character())
expected_classes <- sapply(expected_columns, class)
# Assert that the column classes match the expected classes
expect_equal(sapply(dataset, class), expected_classes,
info = "Column classes should match the expected classes")
})
test_that("create_electrode_dataset output is a datatable", {
# Load the dataset
dataset <- create_electrode_dataset(data_path = "data/input_electrode_burst.csv", recording_identifier = "burst_recording_1")
expect_equal(is.data.table(dataset), TRUE)
})
baseline_data <- create_synchrony_dataset(data_path = "data/input_neuralMetric.csv",
heatmap_condition = "Baseline")
View(baseline_data)
test_that("create_synchrony_dataset output is a data table", {
# Load dataset
dataset <- create_synchrony_dataset(data_path = "data/input_neuralMetric.csv", heatmap_condition = "Baseline")
expect_equal(is.data.table(dataset), TRUE)
})
test_that("create_synchrony_dataset output is a data table", {
# Load dataset
dataset <- create_synchrony_dataset(data_path = "data/input_neuralMetric.csv", heatmap_condition = "Baseline")
expect_equal(is.data.table(dataset), TRUE)
})
test_that("create_synchrony dataset column classes are correct",{
# Load dataset
dataset <- create_synchrony_dataset(data_path = "data/input_neuralMetric.csv", heatmap_condition = "Baseline")
# Define expected column names and classes
expected_columns <- data.table(
Well = character(),
paste0("synchrony_index: ", "Baseline") = numeric())
test_that("create_synchrony dataset column classes are correct",{
# Load dataset
dataset <- create_synchrony_dataset(data_path = "data/input_neuralMetric.csv", heatmap_condition = "Baseline")
# Define expected column names and classes
expected_columns <- data.table(
Well = character(),
paste0("synchrony_index: ", "Baseline") = numeric()
test_that("create_synchrony_dataset output is a data table", {
# Load dataset
dataset <- create_synchrony_dataset(data_path = "data/input_neuralMetric.csv", heatmap_condition = "Baseline")
expect_equal(is.data.table(dataset), TRUE)
})
# Load dataset
dataset <- create_synchrony_dataset(data_path = "data/input_neuralMetric.csv", heatmap_condition = "Baseline")
test_that("create_synchrony_dataset output is a data table", {
# Load dataset
expect_equal(create_synchrony_dataset(data_path = "data/input_neuralMetric.csv", heatmap_condition = "Baseline"), TRUE)
})
test_that("create_synchrony_dataset output is a data table", {
# Load dataset
expect_equal(is.data.table(create_synchrony_dataset(data_path = "data/input_neuralMetric.csv", heatmap_condition = "Baseline")), TRUE)
})
# read in electrode_burst_list file produced by axis navigator software (update data_path accordingly)
input_data <- read_csv(file = data_path, skip = 29, col_names = FALSE, show_col_types = FALSE)
# convert data frame to data table format for efficiency
setDT(input_data)
# extract well and synchrony index data
data_1 <- input_data[str_detect(X1, "Well Averages|Synchrony Index"), ]
# transpose data table
data_2 <- transpose(data_1) %>%
row_to_names(row_number = 1)
View(data_1)
data_path = "data/input_neuralMetric.csv"
eatmap_condition = "Baseline"
# read in electrode_burst_list file produced by axis navigator software (update data_path accordingly)
input_data <- read_csv(file = data_path, skip = 29, col_names = FALSE, show_col_types = FALSE)
problems(input_data)
View(input_data)
read_csv(file = data_path, skip = 29)
read_csv(file = data_path, skip = 29, col_names = FALSE)
?read_csv
input_data <- read_csv(file = data_path, skip = 29, col_names = FALSE, col_types = cols())
input_data <- read_csv(file = data_path, skip = 29)
input_data <- read_csv(file = data_path, skip = 29, col_names = FALSE, show_col_types = FALSE)
problems(data)
problems(dat)
problems(input_data)
input_data <- read_csv(file = data_path, skip = 29, col_names = FALSE, show_col_types = FALSE, num_threads = 1)
test_that("create_synchrony_dataset output is a data table", {
# Load dataset
dataset <- create_synchrony_dataset(data_path = "data/input_neuralMetric.csv", heatmap_condition = "Baseline")
expect_equal(is.data.table(dataset), TRUE)
})
vroom::vroom(input_data)
nput_data <- read_csv(file = data_path, skip = 29, col_names = FALSE, show_col_types = FALSE, na = "NA")
test_that("create_synchrony_dataset output is a data table", {
# Load dataset
dataset <- create_synchrony_dataset(data_path = "data/input_neuralMetric.csv", heatmap_condition = "Baseline")
expect_equal(is.data.table(dataset), TRUE)
})
test_that("create_synchrony dataset column classes are correct",{
# Load dataset
dataset <- create_synchrony_dataset(data_path = "data/input_neuralMetric.csv", heatmap_condition = "Baseline")
# Define expected column names and classes
expected_columns <- data.table(
Well = character(),
paste0("synchrony_index: ", "Baseline") = numeric()
test_that("create_synchrony dataset column classes are correct",{
# Load dataset
dataset <- create_synchrony_dataset(data_path = "data/input_neuralMetric.csv", heatmap_condition = "Baseline")
# Define expected column names and classes
expected_columns <- data.table(
Well = character(),
synchrony_index: Baseline = numeric()
test_that("create_synchrony dataset column classes are correct",{
# Load dataset
dataset <- create_synchrony_dataset(data_path = "data/input_neuralMetric.csv", heatmap_condition = "Baseline")
# Define expected column names and classes
expected_columns <- data.table(
Well = character(),
"synchrony_index: Baseline" = numeric()
)
expected_names <- colnames(expected_columns)
expected_classes <- sapply(expected_columns, class)
# Run checks
expect_equal(colnames(dataset), expected_names, info = "Column names should match the expected names")
expect_equal(sapply(dataset, class), expected_classes, info = "Column classes should match the expected classes")
})
devtools::test()
devtools::test()
devtools::document()
roxygen::reoxygenize()
roxygen2::reoxygenize()
roxygen2::roxygenize()
devtools::document()
?read_csv
test_data_1 <- create_electrode_dataset(data_path = "./data/input_electrode_burst.csv",
recording_identifier = "test_data_1")
test_data_2 <- create_electrode_dataset(data_path = "./data/comparison_agonist_challenge_electrode_burst_list.csv",
recording_identifier = "test_data_2")
output_table <- rbind(test_data_1, test_data_2)
baseline_data <- create_synchrony_dataset(data_path = "./data/input_neuralMetric.csv",
heatmap_condition = "Baseline")
agonist_challenge_data <- create_synchrony_dataset(data_path = "./data/comparison_agonist_challenge_neuralMetrics.csv",
heatmap_condition = "Agonist Challenge")
test_data_1 <- create_electrode_dataset(data_path = "./data/input_electrode_burst.csv",
recording_identifier = "test_data_1")
test_data_2 <- create_electrode_dataset(data_path = "./data/comparison_agonist_challenge_electrode_burst_list.csv",
recording_identifier = "test_data_2")
devtools::document()
devtools::document()
test_that("create_electrode_dataset output is a datatable", {
# Load the dataset
dataset <- create_electrode_dataset(data_path = system.file("extdata", "input_electrode_burst.csv", package = "MEAanalysis"), recording_identifier = "burst_recording_1")
expect_equal(is.data.table(dataset), TRUE)
})
test_that("create_electrode_dataset column names are correct", {
# Load the dataset
dataset <- create_electrode_dataset(data_path = system.file("extdata", "input_electrode_burst.csv", package = "MEAanalysis"), recording_identifier = "burst_recording_1")
# Define expected column names
expected_names <- c("Electrode", "Time_s", "Size_spikes", "Duration_s", "Recording_identifier", "well")
# Assert that the column names match the expected names
expect_equal(colnames(dataset), expected_names,
info = "Column names should match the expected names")
})
test_that("create_electrode_dataset column classes are correct", {
# Load the dataset
dataset <- create_electrode_dataset(data_path = system.file("extdata", "input_electrode_burst.csv", package = "MEAanalysis"), recording_identifier = "burst_recording_1")
# Define expected column classes
expected_columns <- data.table(
Electrode = character(),
Time_s = numeric(),
Size_spikes = numeric(),
Duration_s = numeric(),
Recording_identifier= character(),
well = character())
expected_classes <- sapply(expected_columns, class)
# Assert that the column classes match the expected classes
expect_equal(sapply(dataset, class), expected_classes,
info = "Column classes should match the expected classes")
})
devtools::document
devtools::document()
version()
sessionInfo()
sessionInfo()
sessionInfo()
sessionInfo()
update.packages(ask = FALSE, checkBuilt = TRUE)
sessionInfo()
sessionInfo()
library(knitr)
